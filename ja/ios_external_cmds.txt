*ios_external_cmds.txt*     For Vim version 8.1.    Last change: 2023 Feb 15

			iVim REFERENCE MANUAL	by Terry Chou


					        *ios-external-cmds* 

このファイルは、iVimが提供する外部コマンドのサポートの特殊性を文書化しています。

1. Concepts                             |ios-exter-cmds-concepts|
2. Available Commands                   |ios-exter-cmds-list|
3. Command Personalities                |ios-exter-cmds-personalities|
4. CA Certificates                      |ios-exter-cmds-ca-certs|
5. Input & Output                       |ios-exter-cmds-io|
6. Terminal                             |ios-exter-cmds-term|
7. ivish                                |ivish|


==============================================================================
1. Concepts                                     *ios-exter-cmds-concepts*

プラグインの一部と編集ワークフロー全体を強化するために、iVimには補助ツールとしていくつかの外部コマンドが含まれています。

How it works ~

ここでの「外部コマンド」とは、それ自体が完全なプログラムを意味します。それはvimの機能に依存しません。Vimは入力と出力を介してのみ通信します。
セキュリティのため、iOSはアプリが単独で新しいプログラムを起動することを許可していません。しかし、プロジェクト `ios_system` は、これを克服し、プログラムの立ち上げを可能にするための優れた回避策モデルを提供します。 `ios_system` に特別な感謝と乾杯!

`ios_system` に基づいて、iVimにはいくつかの外部コマンドが含まれており、シェルから来ているように見えます。したがって、 |:!cmd|、|:write_c| または |:read!| などのシェルコマンドのように使用できます。


Plugins ~

外部コマンドは何らかの形で「標準」な方法でiVimに統合されているため、特定の外部コマンドがないために機能しなかった、または正常に機能しなかったプラグインは、現在よりうまく機能または機能するかもしれません。

たとえば、 |netrw| は、コマンド `scp` の可用性のおかげで、 `scp://` プロトコルを介してネットワークコンピュータ上のリモートファイルを編集できるようになりました。


Some tech details ~

通常、プログラムは実行するシステムのプロセスになる必要があります。アプリが新しいプログラムを起動するのを防ぐために、iOSは下のレベルから新しいプロセスを開始する能力を無効にします。一方、プロジェクト `ios_system` (https://github.com/holzschu/ios_system) は、代わりにプログラムをスレッドに入れるように変更することで可能にします。もちろん、このプログラムは、このモデルに合わせて何らかの形で変更する必要があります。


==============================================================================
2. Available Commands                           *ios-exter-cmds-list*

iVimが提供する外部コマンドは、ほとんどのユーザーが慣れ親しんでいて喜んで持っている便利なコマンドラインツールです。さらに、新しいコマンドが追加され、古いコマンドは将来の更新で削除される可能性があります。

その結果、利用可能な外部コマンドのインベントリは、このドキュメントでは詳細に記載されていません。

ただし、他のプラットフォームでのvimのシェルコマンドの仕組みとして、 `:!` を入力した後、いつでも ^D (|c_CTRL-D|) を使用できます。Cmdlineで、現在のバージョンで利用可能なすべての外部コマンドを一覧表示します。また、 `:!` の後に入力した接頭辞を持つ外部コマンドもリストされています。このように。



==============================================================================
3. Command Personalities                        *ios-exter-cmds-personalities*

外部コマンドは `ios_system` モデルで実行するために何らかの形で変更されており、iVimは結局本物のシェルを提供していないため、必然的にユーザーが注意を払わなければならないいくつかの特殊性があるかもしれません。


ただし、将来の更新で変更される可能性があるため、外部コマンドの性格の詳細はこの文書には記載されていません。
代わりに、iVimのプロジェクトウィキページ |ios-exter-cmds-wiki| で入手できます。


Environment variables ~
                                                *ios-exter-cmds-env*
いつものように、1つの外部コマンドは特定の環境変数を尊重する場合があります。言い換えれば、特定の環境変数の値はコマンドの動作を変更します。したがって、これは外部コマンドを構成する方法です。また、wikiページ |ios-exter-cmds-wiki| で関連情報を見つけることができます。


External commands wiki page ~
                                                *ios-exter-cmds-wiki*
外部コマンドに関する最新情報を提供するために、iVimには特定のwikiページがあります。
https://github.com/terrychou/iVim/wiki/External-Commands

そこでは、使用法、設定など、外部コマンドに関する有用な情報を見つけることができます。


==============================================================================
4. CA Certificates                              *ios-exter-cmds-ca-certs*

If you communicate with HTTPS or other TLS(SSL)-using servers via an external command, it may need a CA certificate to do the SSL verification. Otherwise, the communication may fail.

The location of the CA certificate file is given by the environment varibale
`$SSL_CERT_FILE`. 

Because it is kind of private, iVim does not provide this file by default. 
Therefore, you may have to obtain and deploy it by yourself. If you do not have clues on how to do this, there is a wiki page giving related suggestion and instructions:
https://github.com/terrychou/iVim/wiki/External-Command:-curl#ca-certificate


==============================================================================
5. Input & Output                               *ios-exter-cmds-io*

Editing ~

iVim provides an interactive line mode for running external commands. Which means that it waits and accepts your input if the command expects so. 

During the input:

a) it collects and reflects what you have input so far. 

b) you can delete the character before the cursor one by one, but cannot jump among them with the arrow keys. 

c) you confirm your input by inputting a return (new line). When that happens, iVim sends the content collected so far as a whole line to the command.

Control inputs ~

While the external command is running, iVim only accepts two control inputs:

1) `Ctrl-C`
it interrupts the running command. Different commands respond in their different respective ways to this input.

2) `Ctrl-D`
it means the end of the whole input. The command responds in the way when it gets EOF (End Of File).

Command output ~

iVim gets all the content that the command outputs to the standard output or the standard error, and prints it in the message window. Note that you cannot scroll back when the output is more than one screen.


==============================================================================
6. Terminal                                     *ios-exter-cmds-term*

iVim enables the |+terminal| feature. Which means you can also run external commands in a |terminal-window|.

The easiest way to run an external command in a terminal window, is to invoke it via the |:terminal| command: >
        :terminal pwd               "open a terminal window and show current
                                    "directory in it
<
The advantages of running commands in a terminal window include:

a) colors 
the terminal window support the ANSI colors. Commands' output including them will be displayed correctly. Note that iVim also enables |+termguicolors|, so you can set the default 16 ANSI colors used by the terminal via the variable |g:terminal_ansi_colors|.

b) multiple commands simultaneously
unlike running via ex command line, you can open multiple terminal windows and run one command in each, at the same time.

c) more convenient output browsing
While you cannot scroll back to see the earlier output if it exceeds one page in the ex command line, a terminal window, by default, will be kept open after its command is finished. As a result, you are able to browse the whole output as easily as reading a normal document in vim.

d) auto-restore support
if a command was still running in a terminal window when iVim terminated, the related window will be restored automatically at the next launch, with the right command started within it.

See |terminal| for details about the terminal window.

            
==============================================================================
7. ivish                                        *ivish*

To make running external commands in a more continous way, iVim includes a simple shell named `ivish`. You can launch it via: >
        :terminal ivish
<
or just simply: >
        :terminal
<
the difference between them is that in the latter case, the terminal window will be closed automatically when `ivish` exits.

Input & output ~

After `ivish` started, it shows a prompt `$ ` and waits for you to offer a command. `ivish` won't handle your input until you confirm by pressing enter.
After it started, the running command takes over the input and output. Only when it is done, `ivish` comes out again and expects your next command.

Line editing ~
                                                    *ivish-editing*
`ivish` provides a powerful line editing mode for you to edit your input.

`^A`: jump to the start of the line;
`^B`: move one character backward;
`^C`: cancel the current line and start a new prompt;
`^D`: delete the character under the cursor; act like enter if cursor at the
end; Note that if the current line is empty, it exits `ivish`;
`^E`: jump to the end of the line;
`^F`: move one character forward;
`^K`: delete all since the cursor;
`^T`: move one word backward;
`^U`: delete all before the cursor;
`^W`: delete one previous word; Note that since the terminal window eats `^W` use `^W.` to do this;
`^Y`: move one word forward.

Hints & completion ~
                                                    *ivish-completion*
Right now, `ivish` provides completion for the following types:

a) command names
b) file or directory names

During your input, `ivish` watches the cursor position and gives the first of all possible completion candidates as a hint. 

When you press the `tab` key:

a) if there are more than one completion candidates available, `ivish` lists them and complete the word to their longest common prefix;
b) if there is only one candidate, the whole word gets completed;
c) if no candidates available, nothing happens.

Note that hints and completion only work in `ivish` right now, not the running commands.

History ~
                                                    *ivish-history*
Every confirmed line in `ivish` will be recorded as one history item. You can navigate the list via:

`^P` or `up-arrow`: move to the previous line if available;
`^N` or `down-arrow`: move to the next line if available, otherwise return to
the current input;
`esc`: restore to the current input.

You can list the current history items via the internal command `history`.

There are some notes worth mentioning:

a) repeated lines are allowed;
b) at most 100 items are kept in the history;
c) if the env variable `IVISH_HISTORY_FILE` exists, `ivish` loads lines from
it everytime it starts, and saves history into it everytime it terminates;
d) running commands in `ivish` share one history, and it's not saving to a
file.

Internal commands ~
                                                    *ivish-internal-cmds*
`ivish` also provides some internal commands:

`alias`: add or list aliases;
`exit`: terminate the current `ivish` shell;
`help`: show this documentation;
`history`: list the current commands history (|ivish-history|);
`unalias`: remove aliases.

Following lists their details and examples:
						   
alias [name[=value] ...]			    *ivish-inter-cmd-alias*
	    Without any argument, it lists all existing aliases in the form
	    `alias name=value` for each member.

	    When arguments are provided, an alias is created for each name
	    whose value is given. An existing alias with the same name is
	    overwritten with the new value. For each name without any value
	    supplied, the corresponding alias is printed. 

	    For example, this adds a new alias: >
		    alias ll='ls -l'
<
	    Note that there should be no spaces around the "=", otherwise, it
	    would be treated as a bare name: >
		    alias ll = 'ls -l'
<
	    rather than creating an alias, the above command will try to find 
	    aliases with names "ll", "=" and "ls -l", and list them instead.
						    *ivish-alias-illegal-chars*
	    Also, certain characters are illegal for an alias name:

	    1) break characters: `()<>;&| \t\n`
	    2) quote characters: `"'\
	    3) expansion characters: `$<>`
	    4) path separator: `/`

	    attempts to include any of these in an alias name will fail.

	    This lists aliases "ll" and "la": >
		    alias ll la
<
	    Note that `alias` reports an error if it cannot find a name.

exit						    *ivish-inter-cmd-exit*
	    It simply exits the current shell.

help						    *ivish-inter-cmd-help*
	    It opens a help window and jumps to |ivish|.

history						    *ivish-inter-cmd-history*
	    It lists the commands history of the current shell.

unalias [-a] [name ...]				    *ivish-inter-cmd-unalias*
	    It removes existing aliases with the given names.

	    If option `-a` is provided, all existing aliases are cleaned up.

	    Without any argument, nothing happens.

	    For example, this removes aliases "ll" and "la": >
		    unalias ll la
<
	    Note that `unalias` reports an error for each name that it failed
	    to find.
	    
Aliases ~
						    *ivish-aliases*
Aliases are shortcuts for invoking long commands. 

An alias is comprised of a name and a value. Each `ivish` shell maintains an aliases pool. Before executing a command, the shell checks to see if the first word of the command is the name of an existing alias. If so, this word is replaced by the value of the found alias.
						    *ivish-aliases-recursion*
The first word of the replacement text is also tested for aliases. This test continues until a word appears for the second time in this testing chain. For example, if there is an alias `ls='ls -a'`, for the command `ls -l`, the aliases test simply stops after its first "ls" is replaced by "ls -a", rather than replacing the resulting first "ls" again.
						    *ivish-aliases-further-test*
If the last character of one applied alias is a space, the next word in the original command following the alias is also tested for aliases.

For example, if an alias `aa='ls -a '` exists and the command `aa bb` is given.
After the first word "aa" is replaced, the second word "bb" is also checked for possible aliases.
						    *ivish-aliases-cmds*
In `ivish`, aliases are created and listed with command `alias`
(|ivish-inter-cmd-alias|), or removed with command `unalias`
(|ivish-inter-cmd-unalias|).
						    *ivish-aliases-availability*
To make useful aliases as available as possible, `iVim` has a root aliases pool.

Aliases in the root pool are available in the following scenes:

* all external commands share the root aliases pool;
* each `ivish` shell reads aliases from the root pool when it starts.

As a result, you can put commands "!alias name=..." in |.vimrc| to make useful aliases ready whenever `iVim` launches.

Note that however, aliases are not available as commands invoked via |:terminal| 
since this only calls non-builtin commands.
						*ivish-aliases-live-expansion*
At a prompt, `ivish` monitors what you have inputted so far and tries to expand aliases within it. If there is any alias expanded, it displays the resulting command line below the input line, for example: >

	$ ll
	= ls -l
<
in this case, you know exactly what will be executed after you press enter.

Pipes ~
						    *ivish-pipes*
A pipe connects the output of its left command to the input of its right command, and `ivish` supports 2 types of pipes:
						    *ivish-|*
1) `|` normal pipe: >

	command1 | command2
<
it connects the standard output of command1 to the standard input of command2.
						    *ivish-|&*
2) `|&` error combined pipe: >

	command1 |& command2
<
in addition to command1's standard output, it also connects its standard error to command2's standard input.
						    *ivish-pipeline*
Multiple pipes can be chained together to form a pipeline: >

	command1 | command2 |& command3 ...
<
a pipeline waits for all of its commands to terminate before itself exits. The exit status of a pipeline is the exit status of its last command.

Note that each piped command is executed in a subshell, which is a separate shell.

Sequences ~
						    *ivish-sequence*
A sequence is a list of commands or pipelines (|ivish-pipeline|) separated by `;`: >

	ls -al | cat; pwd; uname -a
<
The member commands or pipelines are executed one by one in order. `ivish` waits for all members to terminate in turn. The exit status of the last member is the exit status of the whole sequence.

Caveats ~
						    *ivish-caveats*
Some points concerning using `ivish` are still worth mentioning:

* as a command, `ivish` does not accept or support arguments currently;
* running `ivish` from the command window via ":!ivish" is not supported;
* aliases are not recognized when they are started as jobs from |:terminal|.


==============================================================================
 vim:tw=78:ts=8:noet:ft=help:norl:
